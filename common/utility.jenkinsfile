def myparams() {
    currentBuild.rawBuild.getAction(ParametersAction).getAllParameters()
}

// In order for this function to work you must have variables defined in the scope of the caller:
// ENVID - usually comes from a param
// REG_USEAST1, REG_USEAST2, REG_USWEST2 should map to the envid lists in common/Constants like DEV_GAMEREG_USWEST2
def get_regional_silostrs() {
    def silostrs = []
    if(REG_APSOUTHEAST2.contains(ENVID)) {
        silostrs += "ap-southeast-2-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-reg"
    }
    if(REG_EUCENTRAL1.contains(ENVID)) {
        silostrs += "eu-central-1-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-reg"
    }
    if(REG_EUWEST1.contains(ENVID)) {
        silostrs += "eu-west-1-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-reg"
    }
    if(REG_EUWEST2.contains(ENVID)) {
        silostrs += "eu-west-2-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-reg"
    }
    if(REG_USEAST1.contains(ENVID)) {
        silostrs += "us-east-1-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-reg"
    }
    if(REG_USEAST2.contains(ENVID)) {
        silostrs += "us-east-2-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-reg"
    }
    if(REG_USWEST2.contains(ENVID)) {
        silostrs += "us-west-2-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-reg"
    }
    return silostrs
}

// In order for this function to work you must have variables defined in the scope of the caller:
// ENVID - usually comes from a param
// GLB_USEAST1, GLB_USEAST2, GLB_USWEST2 should map to the envid lists in common/Constants like DEV_GAMEGLB_USWEST2
def get_global_silostr() {
    def silostr = ''
    if(GLB_EUCENTRAL1.contains(ENVID)) {
        silostr = "eu-central-1-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-glb"
    }
    else if(GLB_USEAST1.contains(ENVID)) {
        silostr = "us-east-1-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-glb"
    }
    else if(GLB_USEAST2.contains(ENVID)) {
        silostr = "us-east-2-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-glb"
    }
    else if(GLB_USWEST2.contains(ENVID)) {
        silostr = "us-west-2-${JENKINS_ENVIRONMENT}-vpc-${ENVID}-glb"
    }
    return silostr
}

// In order for this function to work you must have the BCS_ENVIRONMENT parameter in your job
def get_region() {
    def region = ''
    region = env.BCS_ENVIRONMENT.split('-')[0..2].join('-')
    return region
}

def get_silostrs() {
    return [get_global_silostr()] + get_regional_silostrs()
}

// Used to remove boilerplat from the parallel jenkins step, usage should look like:
// parallel utility.parallelize(list_of_things, { println("Some action to perform on every element of ${it}") })
def parallelize(list, closure) {
    def stages = [:]
    list.each {
        stages[it] = {
            closure(it)
            echo "Parallel step ${it} complete"
        }
    }
    return stages
}

def get_files_changed(params = [compare_first_push_against_dev: true]) {
    def files_changed = []
    def changeLogSets = currentBuild.changeSets
    if(changeLogSets.isEmpty() && params.compare_first_push_against_dev) {
        echo 'No files showing as changed meaning this is probably a first push.  Comparing against dev.'
        files_changed = sh( script: 'git diff --name-only `git remote`/dev HEAD', returnStdout: true).tokenize('\n')
    } else {
        for (int i = 0; i < changeLogSets.size(); i++) {
            def entries = changeLogSets[i].items
            for (int j = 0; j < entries.length; j++) {
                def files = new ArrayList(entries[j].affectedFiles)
                for (int k = 0; k < entries[j].affectedFiles.size(); k++) {
                    files_changed << files[k].path
                }
            }
        }
    }
    return files_changed.unique()
}

def email_on_failure(params = [only_on_repeat: false], closure) {
    try {
        closure()
    } catch (Throwable e) {
        if(params.only_on_repeat) {
            if(hudson.model.Result.SUCCESS.equals(currentBuild.rawBuild.getPreviousBuild()?.getResult())) {
                throw e
            }
        }
        email_result('Failed')
        throw e
    }
}

def email_result(result, stable_branches_only=true) {
    // Still cannot figure out a good way to do groovy imports from pipeline code...So duplicating this
    def stable_branches = ['dev', 'main', 'rcpc', 'relpc']
    def branch_name = "${env.JOB_NAME}".split('/').first()
    if(!stable_branches_only || (stable_branches_only && stable_branches.contains(branch_name))) {
        body = """
        Check console output at '${env.BUILD_URL}' to view the results
        """
        subject = "${env.JOB_NAME} - Build ${env.BUILD_DISPLAY_NAME} - ${result}"
        emailext body: body, subject: subject, to: "${env.EMAIL_ALERT}"
    }
}

def set_build_name() {
    if(params.ENVID) {
        currentBuild.displayName = "${env.BUILD_NUMBER} - ${params.ENVID}"
    } else if(params.BCS_ENVIRONMENT) {
        def envid = params.BCS_ENVIRONMENT.split('-')[5]
        currentBuild.displayName = "${env.BUILD_NUMBER} - ${envid}"
    }
}

def slack_message(envid, environment, message, region, scope) {
    println('Trying to send parent Slack msg')
    def TS = ''
    stage("Start Slack thread") {
        TS = sh(script: """#!/bin/bash -e
            export PYTHONPATH=\$WORKSPACE:\$PYTHONPATH
            ./tools/jenkins/slack_msg.py \
            --envid '${envid}' \
            --environment '${environment}' \
            --product '${env.JENKINS_PRODUCT}' \
            --message '${message}' \
            --region '${region}' \
            --scope '${scope}'
            """,
            returnStdout: true
        ).trim()
    }
    param = [string(name: 'SLACK_THREAD_TS', value: TS)]
    return param
}

// This has to be the final line.  Any utility functions must live above return this.
return this
